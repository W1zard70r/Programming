from functools import reduce
import math

# Ваши данные
e = 15
c = [0] * 16
n = [0] * 16

# Заполнение данных (ваши значения)
n[0] = 3221412546660335814044015605715074414953346906864595632887906634736759613305138470951850175704833
c[0] = 1979026010891680123505753742537934827285108182825513898429121531429336267307631721914275446802471

n[1] = 5414926657998658479097935447100066566282466491190169982087350481028866438750859053038021536194913
c[1] = 2632559874648610360291766864103749393250045987719410295641198240729879154385234224826464326125257

n[2] = 3787103620362446699204522508502178457850995769835083542169262176715618169082780280283531692535673
c[2] = 1669856480005981614752925124366290481908577767174702141268722108744644969003836830279098076757510

n[3] = 4262560085189065133882171865688892600501002071393651060533695496019010057326334959328749295122637
c[3] = 2064620841324718312246135530564144128244522538437884506529651417294992726299013173438699159730603

n[4] = 4902285563310257858775897664093842083569464441247411566886281429091440960623504612774006396370169
c[4] = 3777542215915450777463425456567022754083932695519267288035343352995867802044190875607870755030691

n[5] = 7355968702810187507816081257105706324551949102824191536080697466406047318896481316974880498765681
c[5] = 990818853409049706305071854788588742190520373638856652149420198529815225056732010340833830366690

n[6] = 3684706004081312394906923139611304901007508080279803731138339389978579411106631382700649560475357
c[6] = 594727559931548654116847422234447811553874673343331826906389276530150665829413791975538213998327

n[7] = 6047394576168370845099691672886723730403540454815183861485192418234303959572842683358460564241829
c[7] = 4347369863746084389706481931549041286016664252348406421069625450895331118918099430385650235798314

n[8] = 7704262225919603425788589684890997813735624752954830578076780929201142782840438507919353039762561
c[8] = 6516352933135594168445261651746421615018881874645577597696634558281820404689158264502137666344132

n[9] = 6496941133510772702920166729592013667420435441211907217862094936543392502998162153625364716987273
c[9] = 5030749014988121797027751107226864640145243441862362538499706531722393177750909291018952494587114

n[10] = 7021898684942668504604300819521617371059057784341328572996502647246116221781325643120490655366021
c[10] = 4267755836492743443702974202778976567355319244226483962249685239615484773540625123906116688645992

n[11] = 5496084582734592774115683215389623584831620448788923007322191894528493474946603971583862098850357
c[11] = 3516346671185697135825504387379765172176459031637962001395448075016704650173672400126172669813797

n[12] = 4910232303527089360420168483553333584387353981155347858568358740363680397777776246194713939740633
c[12] = 2018233705612260014686743878084348350962660695550260681315936633381919288629178744771924363736934

n[13] = 4665615774949411899453770118271218521589548643038112181462102687452173410059922697959420136574001
c[13] = 3716091828707778871865397797144963143221239386354111769794954610635506430569890318058295596764075

n[14] = 2792656115640394619057346220999722392581980039245613381034292092158233847092719325636508637118029
c[14] = 680922762589820666481506593298446126091065743328311932998936490200857404283796136687648026735924

n[15] = 3565359453284890543662843577062563736976501967642827936099675276530342593552877466650854647353781
c[15] = 3160018573136032035379857737385263436617071981054577159692747284640372402453902647052114473534091

print(f'{len(c)=}, {len(n)=}')

def integer_nth_root(x, n):
    """Вычисление целочисленного корня n-й степени с использованием бинарного поиска"""
    if x == 0:
        return 0
    if x == 1:
        return 1
    
    low = 1
    high = x
    result = 0
    
    while low <= high:
        mid = (low + high) // 2
        power = mid ** n
        
        if power == x:
            return mid
        elif power < x:
            low = mid + 1
            result = mid
        else:
            high = mid - 1
    
    return result

def crt(remainders, moduli):
    """Китайская теорема об остатках"""
    M = reduce(lambda x, y: x * y, moduli, 1)
    Mi = [M // m for m in moduli]
    inv_Mi = [pow(Mi[i], -1, moduli[i]) for i in range(len(moduli))]
    
    result = sum(remainders[i] * Mi[i] * inv_Mi[i] for i in range(len(moduli))) % M
    return result

# Проверяем взаимную простоту модулей
for i in range(len(n)):
    for j in range(i+1, len(n)):
        if math.gcd(n[i], n[j]) != 1:
            print(f"Ошибка: модули {i} и {j} не взаимно просты")
            exit()

# Применяем китайскую теорему об остатках
me = crt(c, n)
print(f"m^e = {me}")

# Извлекаем корень e-й степени
m = integer_nth_root(me, e)
print(f"m = {m}")

# Проверяем результат
if pow(m, e) == me:
    print("Проверка успешна!")
else:
    print("Ошибка: не удалось извлечь точный корень")

# Преобразуем в байты
byte_length = (m.bit_length() + 7) // 8
try:
    message_bytes = m.to_bytes(byte_length, 'big')
    print(f"Message as bytes: {message_bytes}")
    
    # Пробуем декодировать как текст
    try:
        print(f"Message as text: {message_bytes.decode('utf-8')}")
    except UnicodeDecodeError:
        print("Сообщение не является текстом UTF-8")
except OverflowError:
    print("Ошибка преобразования в байты")